<html>
            <head>
            <link rel="icon" href="../res/icon.png">
            <style>body{width:960px; margin:0 auto;}</style>
            <meta charset="utf-8" />
            <title>Set Scrollbar's Value for Unity InputField</title>

            <script src="//code.jquery.com/jquery-1.10.2.js"></script>
            <script src="//cdn.jsdelivr.net/remarkable/1.7.1/remarkable.min.js"></script>
            <script>
            $(function(){
              $("#header").load("../header.html");
              $("#footer").load("../footer.html");
            });
            </script>
            </head>

            <body>
            <div id="header"></div>
            <p id="time"></p>
            <p id="post"></p>

            <script>
            var md = new Remarkable();
            document.getElementById("time").innerHTML = "[Posted on: 20180817]"
document.getElementById("post").innerHTML += md.render('# Set Scrollbar\'s Value for Unity InputField');
document.getElementById("post").innerHTML += md.render('');
document.getElementById("post").innerHTML += md.render('When the InputField is associated with a Scrollbar, the position of the bar can be changed via setting its value attribute.');
document.getElementById("post").innerHTML += md.render('');
document.getElementById("post").innerHTML += md.render('However, if you change scrollbar\'s value (in the script) right after the inputfield\'s content changed, usually it won\'t work as expected. The reason is simple. If the change of the scrollbar\'s value happen in the same Update() scope with the change of content, then the content area has not been updated correctly and hence the bar only change according to the old content.');
document.getElementById("post").innerHTML += md.render('');
document.getElementById("post").innerHTML += md.render('The solution is also simple. If you want to scroll the bar according to the latest content, then you should change scrollbar\'s value in the next (or even later) Update() scope.');
document.getElementById("post").innerHTML += md.render('');
document.getElementById("post").innerHTML += md.render('    private bool contentChanged = false;');
document.getElementById("post").innerHTML += md.render('');
document.getElementById("post").innerHTML += md.render('    void Update ()');
document.getElementById("post").innerHTML += md.render('    {');
document.getElementById("post").innerHTML += md.render('        if (contentChanged)');
document.getElementById("post").innerHTML += md.render('        {');
document.getElementById("post").innerHTML += md.render('            scrollbar.value = 1f; // always scroll to the bottom; change to 0f to scorll to the top');
document.getElementById("post").innerHTML += md.render('            contentChanged = false;');
document.getElementById("post").innerHTML += md.render('        }');
document.getElementById("post").innerHTML += md.render('');
document.getElementById("post").innerHTML += md.render('        // update the content');
document.getElementById("post").innerHTML += md.render('');
document.getElementById("post").innerHTML += md.render('        if (Changed(content))');
document.getElementById("post").innerHTML += md.render('        {');
document.getElementById("post").innerHTML += md.render('            contentChanged = true;');
document.getElementById("post").innerHTML += md.render('        }');
document.getElementById("post").innerHTML += md.render('    }');
document.getElementById("post").innerHTML += md.render('');
document.getElementById("post").innerHTML += md.render('Just for comment, someone suggests doing "Canvas.ForceUpdateCanvases()". However, this doesn\'t always work.');
</script>
            <div id="footer"></div>
            </body>
            </html>